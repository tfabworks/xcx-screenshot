var img$2 = "data:image/png;base64,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";

var img$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA01JREFUeNrsXCuMGkEYHsg5zNWALWhIqENeg4bWonokeFoLoqkAe+BJeig8aMJJXElAAxrTCtB0PnLb7C3LY9nZV+f7kgmv+X9mvvufw+4JQRAEQRAEQRCEY8SumbTf75/kQ97VF8ViH/3cmFzzxKWKmVzzt0uT7q5UBvIeImYcvqw3TickgSQwyrhzIYsAOwvx3pwkLcT4J78JRJZ6CW154WBtMmPThRkDSSAJJEggCSSBLKR9RqlUctX0j0ajF20JlOT9Ei6PyaSOmSTxg3YuLDf+6JY8ow171RVeC/ToMPSTYl3PLtu+2E2yAVnfvXz4rVjtO+nKf3Rx4c8R0Rm8BZ7Isj/leK/4q9ZyVP3O0jEPXfS7HF9DUq515PjhhYt7VcZMFGVYVcAfEp6gvNyJe2B9jyEjz9NyxwsLdF2epNNpkclkRDKZPLzebDZiuVyK1WoVaLnjF4H3twoWi0VRqVT+EWcFiBwMBmI8Hvu+ttD2wkAikRDNZlNks9mz80BsvV4/EN1qtcRutwt87fEwkNduty+SZwbmQgay2hMIi0LMs2I6nR7cFQPP7eIkZINGoC6cy+VEoVB48x4SBdwT8c7qvnBzM9mQhY75fK6nBcqy4oi8RqNxRJ6RQPCZNRNbdWhDIOKX1fo6nc7ZxIDPMMcM6AgyFgZGIOo8q/VdU+fZzbPq0iqJGECh7MVcbQhMpVKO3F97Arfb7VGWvdX9rbq0IBBxzJwwQCA6jGvaPTPZ0KGgR46mC1sL5FqtZltUm4tnzDmnQysC0WXYtXU4UDDHOTzHe3btm1WHVp0IiuNer/fGqgyyMAzXPGWVkLUrurXKwsPh8OTxFIg7RR5kIKt1L2yg2+2KxWJxsMRLJQqSBizPxZng/0egYVFICOVy+dCeWS0P7ozPYXVhOAf0ksD1rYIgxjjCMteGCuPcWvVmvYiBfZVJRnGS6AdCIG7c2x/jwW7u6w/ZVRE+VE/9yI692OxvEpQLg8TnUqkEd/ki1F+BcIvb9gO9jtCJBUYRbiyQl/hGvZAmgSSQIIEkkASSQML/w4S8kzu9/b673WGhnw+CQKf/Y8DvWyomdGHGQBJIKIqBswjuzW3SmtE8CIIgCIIgCMIj/BVgAKofgC9FGz4IAAAAAElFTkSuQmCC";

var en$1 = {
	"screenshot.entry.name": "Screenshot",
	"screenshot.entry.description": "This is an extension to save screenshots as images in costumes."
};
var ja$1 = {
	"screenshot.entry.name": "スクリーンショット",
	"screenshot.entry.description": "画面をコスチュームに保存する"
};
var translations$1 = {
	en: en$1,
	ja: ja$1,
	"ja-Hira": {
	"screenshot.entry.name": "スクリーンショット",
	"screenshot.entry.description": "がめんをこすちゅーむにほぞんする"
},
	"zh-cn": {
	"screenshot.entry.name": "屏幕截图",
	"screenshot.entry.description": "这是一个扩展，可以将屏幕截图保存为服装中的图片。"
},
	"zh-tw": {
	"screenshot.entry.name": "螢幕截圖",
	"screenshot.entry.description": "這是一個擴展，可以將螢幕截圖保存為服裝中的圖片。"
}
};

var formatMessage$1 = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
var setFormatter = function setFormatter(formatter) {
  formatMessage$1 = formatter;
};
var message = function message(key) {
  var id = "".concat(entry.extensionId, ".entry.").concat(key);
  var defaultMessage = translations$1[id] || translations$1.en[id];
  var description = "".concat(key, " of the extension");
  return formatMessage$1({
    id: id,
    defaultMessage: defaultMessage,
    description: description
  });
};
var entry = {
  get name() {
    return message('name');
  },
  get description() {
    return message('description');
  },
  extensionId: 'screenshot',
  extensionURL: 'https://tfabworks.github.io/xcx-screenshot/dist/screenshot.mjs',
  collaborator: 'tfabworks',
  iconURL: img$2,
  insetIconURL: img$1,
  featured: true,
  disabled: false,
  bluetoothRequired: false,
  internetConnectionRequired: false,
  helpLink: 'https://tfabworks.github.io/xcx-screenshot/',
  translationMap: translations$1
};

/**
 * This is an extension for Xcratch
 */
Object.assign(entry, {
  setFormatMessage: function setFormatMessage(formatter) {
    return setFormatter(formatter);
  }
});

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _typeof$1(obj) {
  "@babel/helpers - typeof";

  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$1(obj);
}

function _toPrimitive(input, hint) {
  if (_typeof$1(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$1(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof$1(key) === "symbol" ? key : String(key);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var regeneratorRuntime$1 = {exports: {}};

var _typeof = {exports: {}};

(function (module) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
  }
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof);

(function (module) {
  var _typeof$1 = _typeof.exports["default"];
  function _regeneratorRuntime() {

    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
      return exports;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      defineProperty = Object.defineProperty || function (obj, key, desc) {
        obj[key] = desc.value;
      },
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == _typeof$1(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function value(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method,
        method = delegate.iterator[methodName];
      if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (val) {
      var object = Object(val),
        keys = [];
      for (var key in object) keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function stop() {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(regeneratorRuntime$1);

// TODO(Babel 8): Remove this file.

var runtime = regeneratorRuntime$1.exports();
var regenerator = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if ((typeof globalThis === "undefined" ? "undefined" : _typeof$1(globalThis)) === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

/**
 * Types of block
 * @enum {string}
 */
var BlockType = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',
  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',
  /**
   * Command block
   */
  COMMAND: 'command',
  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',
  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',
  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',
  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',
  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
var blockType = BlockType;

/**
 * Block argument types
 * @enum {string}
 */
var ArgumentType = {
  /**
   * Numeric value with angle picker
   */
  ANGLE: 'angle',
  /**
   * Boolean value with hexagonal placeholder
   */
  BOOLEAN: 'Boolean',
  /**
   * Numeric value with color picker
   */
  COLOR: 'color',
  /**
   * Numeric value with text field
   */
  NUMBER: 'number',
  /**
   * String value with text field
   */
  STRING: 'string',
  /**
   * String value with matrix field
   */
  MATRIX: 'matrix',
  /**
   * MIDI note number with note picker (piano) field
   */
  NOTE: 'note',
  /**
   * Inline image on block (as part of the label)
   */
  IMAGE: 'image'
};
var argumentType = ArgumentType;

var en = {
	"screenshot.name": "Screenshot",
	"screenshot.strftime": "Current Time [FORMAT]",
	"screenshot.saveScreenshot": "Save screenshot to [COSTUME_NAME]",
	"screenshot.saveScreenshot_defaultSpriteName": "Screenshot",
	"screenshot.saveScreenshot_defaultCostumeName": "Screen1"
};
var ja = {
	"screenshot.name": "スクリーンショット",
	"screenshot.strftime": "現在日時[FORMAT]",
	"screenshot.saveScreenshot": "画面を保存[COSTUME_NAME]",
	"screenshot.saveScreenshot_defaultSpriteName": "スクリーン",
	"screenshot.saveScreenshot_defaultCostumeName": "Screen1"
};
var translations = {
	en: en,
	ja: ja,
	"ja-Hira": {
	"screenshot.name": "すくりーんしょっと",
	"screenshot.strftime": "げんざいにちじ[FORMAT]",
	"screenshot.saveScreenshot": "がめんをほぞん[COSTUME_NAME]",
	"screenshot.saveScreenshot_defaultSpriteName": "すくりーん",
	"screenshot.saveScreenshot_defaultCostumeName": "Screen1"
}
};

var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA01JREFUeNrsXCuMGkEYHsg5zNWALWhIqENeg4bWonokeFoLoqkAe+BJeig8aMJJXElAAxrTCtB0PnLb7C3LY9nZV+f7kgmv+X9mvvufw+4JQRAEQRAEQRCEY8SumbTf75/kQ97VF8ViH/3cmFzzxKWKmVzzt0uT7q5UBvIeImYcvqw3TickgSQwyrhzIYsAOwvx3pwkLcT4J78JRJZ6CW154WBtMmPThRkDSSAJJEggCSSBLKR9RqlUctX0j0ajF20JlOT9Ei6PyaSOmSTxg3YuLDf+6JY8ow171RVeC/ToMPSTYl3PLtu+2E2yAVnfvXz4rVjtO+nKf3Rx4c8R0Rm8BZ7Isj/leK/4q9ZyVP3O0jEPXfS7HF9DUq515PjhhYt7VcZMFGVYVcAfEp6gvNyJe2B9jyEjz9NyxwsLdF2epNNpkclkRDKZPLzebDZiuVyK1WoVaLnjF4H3twoWi0VRqVT+EWcFiBwMBmI8Hvu+ttD2wkAikRDNZlNks9mz80BsvV4/EN1qtcRutwt87fEwkNduty+SZwbmQgay2hMIi0LMs2I6nR7cFQPP7eIkZINGoC6cy+VEoVB48x4SBdwT8c7qvnBzM9mQhY75fK6nBcqy4oi8RqNxRJ6RQPCZNRNbdWhDIOKX1fo6nc7ZxIDPMMcM6AgyFgZGIOo8q/VdU+fZzbPq0iqJGECh7MVcbQhMpVKO3F97Arfb7VGWvdX9rbq0IBBxzJwwQCA6jGvaPTPZ0KGgR46mC1sL5FqtZltUm4tnzDmnQysC0WXYtXU4UDDHOTzHe3btm1WHVp0IiuNer/fGqgyyMAzXPGWVkLUrurXKwsPh8OTxFIg7RR5kIKt1L2yg2+2KxWJxsMRLJQqSBizPxZng/0egYVFICOVy+dCeWS0P7ozPYXVhOAf0ksD1rYIgxjjCMteGCuPcWvVmvYiBfZVJRnGS6AdCIG7c2x/jwW7u6w/ZVRE+VE/9yI692OxvEpQLg8TnUqkEd/ki1F+BcIvb9gO9jtCJBUYRbiyQl/hGvZAmgSSQIIEkkASSQML/w4S8kzu9/b673WGhnw+CQKf/Y8DvWyomdGHGQBJIKIqBswjuzW3SmtE8CIIgCIIgCMIj/BVgAKofgC9FGz4IAAAAAElFTkSuQmCC";

/**
 * Formatter which is used for translation.
 * This will be replaced which is used in the runtime.
 * @param {object} messageData - format-message object
 * @returns {string} - message for the locale
 */
var formatMessage = function formatMessage(messageData) {
  return messageData.defaultMessage;
};

/**
 * Setup format-message for this extension.
 */
var setupTranslations = function setupTranslations() {
  var localeSetup = formatMessage.setup ? formatMessage.setup() : null;
  if (localeSetup && localeSetup.translations[localeSetup.locale]) {
    Object.assign(localeSetup.translations[localeSetup.locale], translations[localeSetup.locale]);
  }
};
var EXTENSION_ID = "screenshot";

/**
 * URL to get this extension as a module.
 * When it was loaded as a module, 'extensionURL' will be replaced a URL which is retrieved from.
 * @type {string}
 */
var extensionURL = "https://tfabworks.github.io/xcx-screenshot/dist/screenshot.mjs";

/**
 * Scratch 3.0 blocks for example of Xcratch.
 */
var ExtensionBlocks = /*#__PURE__*/function () {
  /**
   * Construct a set of blocks for Screenshot.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  function ExtensionBlocks(runtime) {
    _classCallCheck(this, ExtensionBlocks);
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;
    if (runtime.formatMessage) {
      // Replace 'formatMessage' to a formatter which is used in the runtime.
      formatMessage = runtime.formatMessage;
    }
    window.xcx_screenshot = this; // DEBUG
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  _createClass(ExtensionBlocks, [{
    key: "getInfo",
    value: function getInfo() {
      setupTranslations();
      return {
        id: ExtensionBlocks.EXTENSION_ID,
        name: ExtensionBlocks.EXTENSION_NAME,
        extensionURL: ExtensionBlocks.extensionURL,
        blockIconURI: img,
        showStatusButton: false,
        blocks: [{
          opcode: "saveScreenshot",
          blockType: blockType.COMMAND,
          text: this.message_saveScreenshot,
          arguments: {
            COSTUME_NAME: {
              type: argumentType.STRING,
              defaultValue: this.message_saveScreenshot_defaultCostumeName
            }
            // SPRITE_NAME: {
            // 	type: ArgumentType.STRING,
            // 	defaultValue: this.getSpriteNamesMenu[0] || "",
            // 	menu: "spriteNamesMenu",
            // },
          }
        }],
        menus: {
          spriteNamesMenu: {
            items: "getSpriteNamesMenu"
          }
        }
      };
    }
  }, {
    key: "getSpriteNamesMenu",
    value: function getSpriteNamesMenu() {
      return this.runtime.targets.filter(function (t) {
        return !t.isStage;
      }).map(function (t) {
        return t.sprite.name;
      });
    }
  }, {
    key: "saveScreenshot",
    value: function () {
      var _saveScreenshot = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(args, util) {
        var spriteName, myTarget, target, costumeName, imageDataUrl, imageData, width, height, center, bitmapResolution, asset, costumeUpdata, costume, currentCostume, skinId, canvas, context;
        return regenerator.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              spriteName = args.SPRITE_NAME || "";
              myTarget = util.target; //コマンドの呼び出し元ターゲット
              target = this.runtime.getSpriteTargetByName(spriteName) || myTarget;
              costumeName = args.COSTUME_NAME || "";
              if (costumeName) {
                _context.next = 6;
                break;
              }
              return _context.abrupt("return");
            case 6:
              window.target = target;
              _context.next = 9;
              return new Promise(function (resolve) {
                target.runtime.renderer.requestSnapshot(function (imageDataURL) {
                  resolve(imageDataURL);
                });
              });
            case 9:
              imageDataUrl = _context.sent;
              _context.next = 12;
              return dataUrlToImageData(imageDataUrl);
            case 12:
              imageData = _context.sent;
              width = imageData.width, height = imageData.height;
              center = [width / 2, height / 2];
              bitmapResolution = 2; // ビットマップの場合は２固定ポイ? https://github.com/xcratch/scratch-gui/blob/a255b910d31098fd728221fc6c27a329d79f184f/src/containers/paint-editor-wrapper.jsx#L34-L39
              // 画像バイナリを Asset に変換
              asset = target.runtime.storage.createAsset(target.runtime.storage.AssetType.ImageBitmap, target.runtime.storage.DataFormat.PNG, dataUrlToUint8Array(imageDataUrl), null,
              // null: auto genenrate id
              true // true: auto generate md5
              ); // コスチュームの雛形オブジェクト
              costumeUpdata = {
                name: costumeName,
                asset: asset,
                dataFormat: asset.dataFormat,
                assetId: asset.assetId,
                md5: "".concat(asset.assetId, ".").concat(asset.dataFormat),
                size: [width, height],
                rotationCenterX: center[0],
                rotationCenterY: center[1],
                bitmapResolution: bitmapResolution
              }; // 名前から既存のコスチュームを探す
              costume = target.getCostumes().find(function (c) {
                return c.name === costumeName;
              });
              if (costume) {
                _context.next = 29;
                break;
              }
              // 新規作成
              // 現在選択中のコスチュームを保存
              currentCostume = target.currentCostume; // 新しい skinId を取得（スキンIDは全コスチューム）
              skinId = target.renderer.createBitmapSkin(imageData, bitmapResolution, center);
              costumeUpdata.skinId = skinId;
              _context.next = 25;
              return target.addCostume(costumeUpdata);
            case 25:
              target.setCostume(target.getCostumes().length - 1);
              // 新規（addCostumeすると最新のコスチュームが選択されてしまうが、コスチュームの選択は元のままにする）
              target.setCostume(currentCostume);
              _context.next = 35;
              break;
            case 29:
              // 上書き
              // 本当は runtime.vm.updateBitmap() を使えば楽ぽいけど、ターゲットが editingTarget 固定なので使えないので、必要な処理を参考にしつつ自分で書いた
              // https://github.com/xcratch/scratch-vm/blob/05a1dcd2bd9037741de8cbb7620edbbb5eb1284d/src/virtual-machine.js#L888-L939
              Object.assign(costume, costumeUpdata);
              // renderer.updateBitmapSkin に渡すために canvas に変換
              canvas = Object.assign(document.createElement('canvas'), {
                width: width,
                height: height
              });
              context = canvas.getContext('2d');
              context.putImageData(imageData, 0, 0);
              // レンダラーが持ってるBitmapSkinも更新する必要がある
              target.renderer.updateBitmapSkin(costume.skinId, canvas, costume.bitmapResolution, center);
              target.runtime.requestTargetsUpdate(costume);
            case 35:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function saveScreenshot(_x, _x2) {
        return _saveScreenshot.apply(this, arguments);
      }
      return saveScreenshot;
    }() /** @private @type {string} id @return {string} */
  }, {
    key: "_message",
    value: function _message(id) {
      var id2 = "".concat(EXTENSION_ID, ".").concat(id);
      return formatMessage({
        id: id2,
        default: translations.en[id2]
      });
    }
    /** @private */
  }, {
    key: "message_saveScreenshot",
    get: function get() {
      return this._message("saveScreenshot");
    }
    /** @private */
  }, {
    key: "message_saveScreenshot_defaultCostumeName",
    get: function get() {
      return this._message("saveScreenshot_defaultCostumeName");
    }
  }], [{
    key: "formatMessage",
    set:
    /**
        * A translation object which is used in this class.
        * @param {FormatObject} formatter - translation object
        */
    function set(formatter) {
      formatMessage = formatter;
      if (formatMessage) setupTranslations();
    }

    /**
     * @return {string} - the name of this extension.
     */
  }, {
    key: "EXTENSION_NAME",
    get: function get() {
      return formatMessage({
        id: "screenshot.name",
        default: translations.en["screenshot.name"],
        description: "name of the extension"
      });
    }

    /**
     * @return {string} - the ID of this extension.
     */
  }, {
    key: "EXTENSION_ID",
    get: function get() {
      return EXTENSION_ID;
    }

    /**
     * URL to get this extension.
     * @type {string}
     */
  }, {
    key: "extensionURL",
    get: function get() {
      return extensionURL;
    }

    /**
     * Set URL to get this extension.
     * The extensionURL will be changed to the URL of the loading server.
     * @param {string} url - URL
     */,
    set: function set(url) {
      extensionURL = url;
    }
  }]);
  return ExtensionBlocks;
}();
var dataUrlToUint8Array = function dataUrlToUint8Array(url) {
  return base64ToUint8Array(url.substr(url.indexOf(";base64,") + 8) || "");
};
var base64ToUint8Array = function base64ToUint8Array(b64) {
  return new Uint8Array([].map.call(atob(b64), function (c) {
    return c.charCodeAt(0);
  }));
};
var dataUrlToImageData = function dataUrlToImageData(url) {
  return new Promise(function (resolve, reject) {
    if (url == null || url === "") {
      return reject();
    }
    var img = Object.assign(new Image(), {
      src: url,
      onerror: reject,
      onload: function onload() {
        var canvas = Object.assign(document.createElement("canvas"), {
          width: img.width,
          height: img.height
        });
        var ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        resolve(imageData);
      }
    });
  });
};

export { ExtensionBlocks as blockClass, entry };
